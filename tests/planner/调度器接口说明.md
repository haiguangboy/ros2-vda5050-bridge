# è°ƒåº¦å™¨æ¥å£è¯´æ˜æ–‡æ¡£

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯´æ˜è°ƒåº¦å™¨å¦‚ä½•ä¸è½¨è¿¹è§„åˆ’å™¨äº¤äº’ï¼ŒåŒ…æ‹¬å‘é€ç›®æ ‡ç‚¹å’ŒæŸ¥è¯¢è½¨è¿¹çŠ¶æ€ã€‚

---

## 1. å‘é€ç›®æ ‡ç‚¹æ¥å£

### æ–¹å¼1ï¼šä½¿ç”¨GoToPose Serviceï¼ˆæ¨èï¼Œå·²å®ç°âœ…ï¼‰

**Serviceåç§°**ï¼š`/go_to_pose`

**Serviceç±»å‹**ï¼š`forklift_interfaces/srv/GoToPose`

**Serviceå®šä¹‰**ï¼š
```
# è¯·æ±‚
uint8 MODE_NORMAL=0
uint8 MODE_FORK=1
uint8 mode
geometry_msgs/PoseStamped target
float32 timeout_sec
geometry_msgs/Pose pallet_pose      # æ‰˜ç›˜ä½ç½®ï¼ˆmode=1æ—¶ä½¿ç”¨ï¼‰
geometry_msgs/Vector3 pallet_size   # æ‰˜ç›˜å°ºå¯¸ï¼ˆmode=1æ—¶ä½¿ç”¨ï¼‰
---
# å“åº”
bool arrived     # æ˜¯å¦æ¥å—ç›®æ ‡ç‚¹
string message   # çŠ¶æ€æ¶ˆæ¯
```

**è°ƒåº¦å™¨è°ƒç”¨ç¤ºä¾‹**ï¼š
```python
from forklift_interfaces.srv import GoToPose
from geometry_msgs.msg import PoseStamped
import math

# åˆ›å»ºserviceå®¢æˆ·ç«¯
client = node.create_client(GoToPose, '/go_to_pose')
client.wait_for_service()

# æ„é€ è¯·æ±‚
request = GoToPose.Request()
request.mode = GoToPose.Request.MODE_NORMAL  # æˆ– MODE_FORK
request.timeout_sec = 60.0

# è®¾ç½®ç›®æ ‡ä½ç½®
request.target = PoseStamped()
request.target.header.frame_id = "map"
request.target.pose.position.x = 3.0
request.target.pose.position.y = 0.0
request.target.pose.position.z = 0.0
request.target.pose.orientation = yaw_to_quaternion(math.radians(90))

# è°ƒç”¨service
future = client.call_async(request)
rclpy.spin_until_future_complete(node, future)

response = future.result()
if response.arrived:
    print(f"âœ… ç›®æ ‡ç‚¹å·²æ¥å—: {response.message}")
else:
    print(f"âŒ ç›®æ ‡ç‚¹è¢«æ‹’ç»: {response.message}")
```

**å“åº”è¯´æ˜**ï¼š
- `arrived=True`: ç›®æ ‡ç‚¹å·²æ¥å—ï¼Œè½¨è¿¹è§„åˆ’ä¸­
- `arrived=False`: ç›®æ ‡ç‚¹è¢«æ‹’ç»ï¼ˆåŸå› è§messageï¼‰

**è°ƒåº¦å™¨è°ƒç”¨ç¤ºä¾‹**ï¼ˆPythonï¼‰ï¼š
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from forklift_interfaces.srv import GoToPose
from geometry_msgs.msg import PoseStamped

class SchedulerClient(Node):
    def __init__(self):
        super().__init__('scheduler_client')
        self.client = self.create_client(GoToPose, '/go_to_pose')

    def send_goal(self, x, y, yaw, mode=0):
        request = GoToPose.Request()
        request.mode = mode
        request.target = PoseStamped()
        request.target.header.frame_id = "map"
        request.target.pose.position.x = x
        request.target.pose.position.y = y
        request.target.pose.orientation = self.yaw_to_quaternion(yaw)
        request.timeout_sec = 60.0

        future = self.client.call_async(request)
        return future
```

### æ–¹å¼2ï¼šä½¿ç”¨è¯é¢˜å‘å¸ƒï¼ˆå½“å‰å®ç°ï¼‰

**è¯é¢˜åç§°**ï¼š`/nav_goal`

**æ¶ˆæ¯ç±»å‹**ï¼š`geometry_msgs/msg/PoseStamped`

**å‘å¸ƒç¤ºä¾‹**ï¼š
```python
from geometry_msgs.msg import PoseStamped

goal = PoseStamped()
goal.header.frame_id = "map"
goal.pose.position.x = 3.0
goal.pose.position.y = 0.0
goal.pose.orientation.w = 1.0  # æˆ–ä½¿ç”¨å››å…ƒæ•°

publisher.publish(goal)
```

**å‘½ä»¤è¡Œå‘å¸ƒç¤ºä¾‹**ï¼š
```bash
# å‘å¸ƒè§‚å¯Ÿç‚¹
python3 publish_test_goal.py --x 3.0 --y 0.0 --yaw-deg 90

# å‘å¸ƒå–è´§ç‚¹
python3 publish_test_goal.py --x 4.0 --y 1.0 --yaw-deg 90
```

---

## 2. æŸ¥è¯¢è½¨è¿¹çŠ¶æ€æ¥å£

### Serviceæ¥å£

**Serviceåç§°**ï¼š`/trajectory_status`

**Serviceç±»å‹**ï¼š`example_interfaces/srv/Trigger`ï¼ˆå½“å‰ï¼‰æˆ– `TrajectoryStatus`ï¼ˆæ¨èï¼‰

### å½“å‰å®ç°ï¼ˆä½¿ç”¨Triggerï¼‰

**è¯·æ±‚**ï¼šæ— å‚æ•°

**å“åº”**ï¼š
```python
response.success  # bool: æŸ¥è¯¢æ˜¯å¦æˆåŠŸ
response.message  # string: JSONæ ¼å¼çš„çŠ¶æ€æ•°æ®
```

**å“åº”JSONæ ¼å¼**ï¼š
```json
{
  "trajectory_id": "observation_1759674102825",
  "status": "completed",
  "timestamp": 1759674102825,
  "message": "è½¨è¿¹æ‰§è¡Œå®Œæˆ"
}
```

**çŠ¶æ€å€¼è¯´æ˜**ï¼š
- `no_data`: æš‚æ— è½¨è¿¹æ•°æ®
- `pending`: è½¨è¿¹ç­‰å¾…æ‰§è¡Œ
- `running`: è½¨è¿¹æ­£åœ¨æ‰§è¡Œ
- `completed`: è½¨è¿¹å·²å®Œæˆ
- `failed`: è½¨è¿¹æ‰§è¡Œå¤±è´¥

**è°ƒåº¦å™¨æŸ¥è¯¢ç¤ºä¾‹**ï¼ˆPythonï¼‰ï¼š
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from example_interfaces.srv import Trigger
import json

class StatusQueryClient(Node):
    def __init__(self):
        super().__init__('status_query_client')
        self.client = self.create_client(Trigger, '/trajectory_status')

    def query_status(self):
        request = Trigger.Request()
        future = self.client.call_async(request)

        rclpy.spin_until_future_complete(self, future)

        if future.result() is not None:
            response = future.result()
            if response.success:
                status_data = json.loads(response.message)
                print(f"è½¨è¿¹ID: {status_data['trajectory_id']}")
                print(f"çŠ¶æ€: {status_data['status']}")
                print(f"æ—¶é—´æˆ³: {status_data['timestamp']}")
                print(f"æ¶ˆæ¯: {status_data['message']}")
                return status_data
        return None

# ä½¿ç”¨ç¤ºä¾‹
rclpy.init()
client = StatusQueryClient()
client.client.wait_for_service(timeout_sec=5.0)
status = client.query_status()
```

**å‘½ä»¤è¡ŒæŸ¥è¯¢ç¤ºä¾‹**ï¼š
```bash
python3 query_trajectory_status.py
```

### æ¨èå®ç°ï¼ˆä½¿ç”¨è‡ªå®šä¹‰srvï¼‰

**Serviceç±»å‹**ï¼š`TrajectoryStatus`ï¼ˆè§ `srv/TrajectoryStatus.srv`ï¼‰

**å“åº”æ ¼å¼**ï¼š
```python
response.success        # bool: æŸ¥è¯¢æ˜¯å¦æˆåŠŸ
response.trajectory_id  # string: è½¨è¿¹ID
response.status         # string: çŠ¶æ€
response.timestamp      # int64: æ—¶é—´æˆ³
response.message        # string: æè¿°ä¿¡æ¯
```

---

## 3. å®Œæ•´å·¥ä½œæµç¨‹

### è§‚å¯Ÿç‚¹ â†’ å–è´§ç‚¹æµç¨‹

```
è°ƒåº¦å™¨                     è½¨è¿¹è§„åˆ’å™¨                    æ‰§è¡Œå™¨
  â”‚                            â”‚                          â”‚
  â”œâ”€ å‘å¸ƒè§‚å¯Ÿç‚¹ /nav_goal â”€â”€â”€â†’â”‚                          â”‚
  â”‚  (3.0, 0.0, 90Â°)          â”‚                          â”‚
  â”‚                            â”œâ”€ è§„åˆ’ç®€å•è½¨è¿¹            â”‚
  â”‚                            â”œâ”€ å‘å¸ƒåˆ° /plans â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
  â”‚                            â”‚                          â”‚
  â”‚                            â”‚                    æ‰§è¡Œè½¨è¿¹
  â”‚                            â”‚                          â”‚
  â”‚                            â”‚â†â”€ MQTTå®Œæˆä¿¡å· â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                            â”‚                          â”‚
  â”‚                            â”œâ”€ æ›´æ–°/Odomä¸ºç»ˆç‚¹         â”‚
  â”‚                            â”‚                          â”‚
  â”œâ”€ å‘å¸ƒå–è´§ç‚¹ /nav_goal â”€â”€â”€â†’â”‚                          â”‚
  â”‚  (4.0, 1.0, 90Â°)          â”‚                          â”‚
  â”‚                            â”œâ”€ è§„åˆ’å¤æ‚è½¨è¿¹ï¼ˆå‰å‘ï¼‰    â”‚
  â”‚                            â”œâ”€ å‘å¸ƒåˆ° /plans â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
  â”‚                            â”‚                          â”‚
  â”‚                            â”‚                    æ‰§è¡Œå‰å‘
  â”‚                            â”‚                          â”‚
  â”‚                            â”‚â†â”€ MQTTå®Œæˆä¿¡å· â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                            â”‚                          â”‚
  â”‚                            â”œâ”€ è§„åˆ’å¤æ‚è½¨è¿¹ï¼ˆå€’è½¦ï¼‰    â”‚
  â”‚                            â”œâ”€ å‘å¸ƒåˆ° /plans â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
  â”‚                            â”‚                          â”‚
  â”‚                            â”‚                    æ‰§è¡Œå€’è½¦
  â”‚                            â”‚                          â”‚
  â”‚                            â”‚â†â”€ MQTTå®Œæˆä¿¡å· â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                            â”‚                          â”‚
  â”œâ”€ æŸ¥è¯¢çŠ¶æ€ /trajectory_statusâ”‚                         â”‚
  â”‚                            â”‚                          â”‚
  â”‚â†â”€ è¿”å›completedçŠ¶æ€ â”€â”€â”€â”€â”€â”€â”€â”¤                          â”‚
  â”‚                            â”‚                          â”‚
  âœ… ä»»åŠ¡å®Œæˆ
```

### è°ƒåº¦å™¨ç¤ºä¾‹ä»£ç 

```python
#!/usr/bin/env python3
"""è°ƒåº¦å™¨ç¤ºä¾‹ - å®Œæ•´æµç¨‹"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from example_interfaces.srv import Trigger
import json
import time
import math

class Scheduler(Node):
    def __init__(self):
        super().__init__('scheduler')

        # å‘å¸ƒå™¨
        self.goal_publisher = self.create_publisher(PoseStamped, '/nav_goal', 10)

        # æœåŠ¡å®¢æˆ·ç«¯
        self.status_client = self.create_client(Trigger, '/trajectory_status')

    def send_observation_point(self):
        """å‘é€è§‚å¯Ÿç‚¹"""
        goal = PoseStamped()
        goal.header.frame_id = "map"
        goal.pose.position.x = 3.0
        goal.pose.position.y = 0.0
        goal.pose.orientation = self.yaw_to_quaternion(math.pi/2)  # 90åº¦

        self.goal_publisher.publish(goal)
        print("ğŸ“¤ å·²å‘å¸ƒè§‚å¯Ÿç‚¹: (3.0, 0.0, 90Â°)")

    def send_pickup_point(self):
        """å‘é€å–è´§ç‚¹"""
        goal = PoseStamped()
        goal.header.frame_id = "map"
        goal.pose.position.x = 4.0
        goal.pose.position.y = 1.0
        goal.pose.orientation = self.yaw_to_quaternion(math.pi/2)  # 90åº¦

        self.goal_publisher.publish(goal)
        print("ğŸ“¤ å·²å‘å¸ƒå–è´§ç‚¹: (4.0, 1.0, 90Â°)")

    def query_status(self):
        """æŸ¥è¯¢è½¨è¿¹çŠ¶æ€"""
        request = Trigger.Request()
        future = self.status_client.call_async(request)

        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)

        if future.result() is not None:
            response = future.result()
            if response.success:
                status_data = json.loads(response.message)
                return status_data
        return None

    def wait_for_completion(self, timeout=60.0):
        """ç­‰å¾…è½¨è¿¹å®Œæˆ"""
        start_time = time.time()
        while (time.time() - start_time) < timeout:
            status = self.query_status()
            if status and status['status'] == 'completed':
                print(f"âœ… è½¨è¿¹å®Œæˆ: {status['trajectory_id']}")
                return True
            time.sleep(1.0)
        return False

    @staticmethod
    def yaw_to_quaternion(yaw):
        from geometry_msgs.msg import Quaternion
        q = Quaternion()
        q.w = math.cos(yaw * 0.5)
        q.z = math.sin(yaw * 0.5)
        return q

def main():
    rclpy.init()
    scheduler = Scheduler()

    # ç­‰å¾…æœåŠ¡å¯ç”¨
    scheduler.status_client.wait_for_service(timeout_sec=10.0)

    # 1. å‘é€è§‚å¯Ÿç‚¹
    print("\n=== æ­¥éª¤1: å‘é€è§‚å¯Ÿç‚¹ ===")
    scheduler.send_observation_point()

    # 2. ç­‰å¾…è§‚å¯Ÿç‚¹å®Œæˆ
    print("â³ ç­‰å¾…è§‚å¯Ÿç‚¹è½¨è¿¹å®Œæˆ...")
    if scheduler.wait_for_completion(timeout=60.0):
        time.sleep(2)  # ç­‰å¾…2ç§’

        # 3. å‘é€å–è´§ç‚¹
        print("\n=== æ­¥éª¤2: å‘é€å–è´§ç‚¹ ===")
        scheduler.send_pickup_point()

        # 4. ç­‰å¾…å–è´§å®Œæˆ
        print("â³ ç­‰å¾…å–è´§è½¨è¿¹å®Œæˆ...")
        if scheduler.wait_for_completion(timeout=120.0):
            print("\nğŸ‰ æ‰€æœ‰ä»»åŠ¡å®Œæˆï¼")
        else:
            print("\nâŒ å–è´§ä»»åŠ¡è¶…æ—¶")
    else:
        print("\nâŒ è§‚å¯Ÿç‚¹ä»»åŠ¡è¶…æ—¶")

    scheduler.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

---

## 4. æ¥å£æ–‡ä»¶ä½ç½®

### Serviceå®šä¹‰æ–‡ä»¶

1. **GoToPose.srv** (è°ƒåº¦å™¨æ ¼å¼)
   ```
   /home/yhg/Documents/ep-embodied/forklift_interfaces/srv/GoToPose.srv
   ```

2. **TrajectoryStatus.srv** (æ¨èçš„çŠ¶æ€æŸ¥è¯¢æ ¼å¼)
   ```
   /home/yhg/Documents/ep-embodied/mqtt_bridge/tests/planner/srv/TrajectoryStatus.srv
   ```

### å½“å‰å¯ç”¨çš„Serviceå’ŒTopic

| åç§° | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `/nav_goal` | Topic (PoseStamped) | ç›®æ ‡ç‚¹å‘å¸ƒ |
| `/trajectory_status` | Service (Trigger) | è½¨è¿¹çŠ¶æ€æŸ¥è¯¢ |
| `/Odom` | Topic (Odometry) | å½“å‰ä½ç½®ï¼ˆè‡ªåŠ¨æ›´æ–°ï¼‰ |
| `/plans` | Topic (Path) | è§„åˆ’çš„è½¨è¿¹è·¯å¾„ |

---

## 5. æµ‹è¯•å·¥å…·

### å‘å¸ƒç›®æ ‡ç‚¹
```bash
# è§‚å¯Ÿç‚¹
python3 publish_test_goal.py --x 3.0 --y 0.0 --yaw-deg 90

# å–è´§ç‚¹
python3 publish_test_goal.py --x 4.0 --y 1.0 --yaw-deg 90
```

### æŸ¥è¯¢çŠ¶æ€
```bash
python3 query_trajectory_status.py
```

### å¯åŠ¨è§„åˆ’å™¨
```bash
python3 unified_planner_workflow.py
```

---

## 6. è°ƒåº¦å™¨é›†æˆæ¸…å•

- [ ] ç¡®è®¤è°ƒåº¦å™¨ä½¿ç”¨çš„Service/Topicç±»å‹
- [ ] æ ¹æ®éœ€è¦è°ƒæ•´æ¥å£æ ¼å¼ï¼ˆGoToPose vs PoseStampedï¼‰
- [ ] å®ç°çŠ¶æ€æŸ¥è¯¢é€»è¾‘
- [ ] å®ç°è¶…æ—¶å¤„ç†
- [ ] å®ç°é”™è¯¯é‡è¯•æœºåˆ¶
- [ ] é›†æˆåˆ°è°ƒåº¦ç³»ç»Ÿä¸­

---

## 7. å¸¸è§é—®é¢˜

### Q1: è°ƒåº¦å™¨åº”è¯¥ä½¿ç”¨Serviceè¿˜æ˜¯Topicå‘é€ç›®æ ‡ç‚¹ï¼Ÿ

**A**: æ¨èä½¿ç”¨Topic (`/nav_goal`)ï¼Œå› ä¸ºå½“å‰å®ç°åŸºäºTopicã€‚å¦‚æœéœ€è¦Serviceï¼Œå¯ä»¥åœ¨`unified_planner_workflow.py`ä¸­æ·»åŠ GoToPose ServiceæœåŠ¡å™¨ã€‚

### Q2: å¦‚ä½•çŸ¥é“è½¨è¿¹æ˜¯å¦å®Œæˆï¼Ÿ

**A**: ä¸¤ç§æ–¹å¼ï¼š
1. è°ƒç”¨ `/trajectory_status` serviceæŸ¥è¯¢çŠ¶æ€
2. è®¢é˜…MQTTä¸»é¢˜ `EP/robot-001/cerebellum/embrain/trajectory_status`

### Q3: ç¬¬2ä¸ªç›®æ ‡ç‚¹ä»€ä¹ˆæ—¶å€™å‘é€ï¼Ÿ

**A**: ç­‰ç¬¬1ä¸ªè½¨è¿¹çŠ¶æ€å˜ä¸º `completed` åå†å‘é€ã€‚å»ºè®®é—´éš”2-3ç§’ã€‚

### Q4: å¦‚ä½•åŒºåˆ†è§‚å¯Ÿç‚¹å’Œå–è´§ç‚¹ï¼Ÿ

**A**: æŒ‰é¡ºåºå‘é€ï¼š
- ç¬¬1ä¸ªç‚¹è‡ªåŠ¨è¯†åˆ«ä¸ºè§‚å¯Ÿç‚¹ï¼ˆSimpleTrajectoryPlannerï¼‰
- ç¬¬2ä¸ªç‚¹è‡ªåŠ¨è¯†åˆ«ä¸ºå–è´§ç‚¹ï¼ˆComplexTrajectoryPlanner + å€’è½¦ï¼‰

---

## 8. è”ç³»æ–¹å¼

å¦‚æœ‰é—®é¢˜ï¼Œè¯·æŸ¥çœ‹ï¼š
- ä»£ç ä»“åº“ï¼š`/home/yhg/Documents/ep-embodied/mqtt_bridge/tests/planner/`
- æµ‹è¯•æ–‡æ¡£ï¼š`ç»Ÿä¸€è§„åˆ’å™¨ä½¿ç”¨æŒ‡å—.md`
- ç¤ºä¾‹ä»£ç ï¼š`unified_planner_workflow.py`
