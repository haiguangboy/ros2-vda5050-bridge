# ComplexTrajectoryPlanner 闭环测试 - 快速步骤

## 新增文件说明

### mock_executor.py - 模拟执行器（关键！）

**作用**：模拟真实的轨迹执行器，接收轨迹后返回MQTT执行状态

**核心功能**：
```python
# 1. 订阅 /plans 话题，接收轨迹
self.path_subscriber = self.create_subscription(Path, '/plans', self.path_callback, 10)

# 2. 收到轨迹后，发布MQTT "running"状态
self.publish_trajectory_status(trajectory_id, "running", "轨迹执行中")

# 3. 模拟执行（延时）
time.sleep(total_time)

# 4. 执行完成后，发布MQTT "completed"状态
self.publish_trajectory_status(trajectory_id, "completed", "轨迹执行完成")
```

**MQTT消息格式**：
```json
{
  "trajectoryId": "complex_forward_1234567890",
  "status": "completed",
  "timestamp": 1696483200000,
  "message": "轨迹执行完成"
}
```

**发布主题**：
```
EP/robot-001/cerebellum/embrain/trajectory_status
```

---

## 测试步骤（5个终端）

### 第1步：启动MQTT Bridge（终端1）

```bash
cd /home/yhg/Documents/ep-embodied/mqtt_bridge/tests/planner
./start_mqtt_bridge.sh
```

**看到这个输出表示成功**：
```
✅ 中力MQTT客户端已创建 - Robot ID: robot-001
✅ 已连接到EMQX服务器
```

---

### 第2步：启动模拟执行器（终端2）⭐ 关键新增！

```bash
cd /home/yhg/Documents/ep-embodied/mqtt_bridge/tests/planner
python3 mock_executor.py
```

**看到这个输出表示成功**：
```
🎮 模拟轨迹执行器
================================================================================
功能:
  1. 接收 /plans 轨迹指令
  2. 模拟执行轨迹（延时）
  3. 发布MQTT状态消息（running → completed）
  4. 更新 /Odom 当前位置
================================================================================

✅ 模拟执行器已启动
   订阅: /plans
   发布: /Odom (当前位置)
   MQTT: 发布轨迹状态

🚀 连接到MQTT代理: localhost:1883
✅ MQTT已连接

💡 执行器运行中，按 Ctrl+C 停止
```

⚠️ **这个程序必须运行！否则测试会卡住！**

---

### 第3步：发布起点Odom（终端3）

```bash
cd /home/yhg/Documents/ep-embodied/mqtt_bridge/tests/planner
python3 publish_test_odom.py --x 3.0 --y 0.0 --yaw-deg -90
```

**看到这个输出表示成功**：
```
✅ 持续发布Odom数据到 /Odom:
   位置: (3.000, 0.000)
   朝向: -1.570 rad (-90.0°)
```

---

### 第4步：启动测试节点（终端4）

```bash
cd /home/yhg/Documents/ep-embodied/mqtt_bridge/tests/planner
python3 test_complex_planner_workflow.py
```

**看到这个输出表示成功**：
```
✅ ComplexPlannerTester 节点已启动
✅ 已接收到 /Odom 话题数据
   当前位置: (3.000, 0.000), 朝向: -1.571 (-90.0°)

⏳ 等待目标点 /nav_goal 话题数据...
```

---

### 第5步：发布目标点（终端5）

```bash
cd /home/yhg/Documents/ep-embodied/mqtt_bridge/tests/planner
python3 publish_test_goal.py --x 4.0 --y 1.0 --yaw-deg 90
```

**看到这个输出表示成功**：
```
✅ 准备发布目标点到 /nav_goal:
   位置: (4.000, 1.000)
   朝向: 1.570 rad (90.0°)

📤 已发布 20/20 次...
✅ 已发布 20 次，完成
```

---

## 完整流程观察

### 终端4（测试节点）的完整输出

```
================================================================================
📤 规划并发布前向轨迹（Traj1 + Traj2 组合）
================================================================================
📍 起点: (3.000, 0.000), yaw=-1.571 (-90.0°)
📍 终点: (4.000, 1.000), yaw=1.571 (90.0°)

✅ 前向轨迹生成完成，共 12 个路径点

所有路径点:
  点1: x=3.000, y=0.000, yaw=-1.571 (-90.0°)
  点2: x=3.000, y=0.000, yaw=-0.785 (-45.0°)
  ...
  点12: x=4.000, y=1.000, yaw=1.571 (90.0°)

Beta-3参数: orientation=0.0, flag=0 (前向运动)
================================================================================
📤 轨迹已发布到 /plans
📋 轨迹ID: complex_forward_1728087654321

⏳ 等待MQTT轨迹完成信号（按Ctrl+C可中断）...    ← 【以前这里会卡住！】
```

### 终端2（模拟执行器）的输出 ⭐ 关键！

```
================================================================================
📥 收到轨迹指令                                   ← 【收到轨迹】
================================================================================
📋 轨迹ID: complex_forward_1728087654321
📍 路径点数: 12
🔄 orientation: 0.0
🌿 flag: 0

起点: (3.000, 0.000), yaw=-90.0°
终点: (4.000, 1.000), yaw=90.0°

执行估算:
  移动距离: 1.414 m
  旋转角度: 180.0°
  预计时间: 1.2 秒
================================================================================
📤 发布状态: running                              ← 【发布MQTT "running"】

⏳ 模拟执行轨迹... (1.2秒)
  进度: 40% - 位置: (3.42, 0.42)
  进度: 80% - 位置: (3.85, 0.85)
✅ 执行完成

📤 发布状态: completed                            ← 【发布MQTT "completed"】
📍 当前位置: (4.000, 1.000), yaw=90.0°
```

### 终端4（测试节点）继续输出

```
================================================================================
📊 收到MQTT轨迹状态消息                           ← 【收到完成信号，不再卡住！】
================================================================================
📋 轨迹ID: complex_forward_1728087654321
📍 状态: completed
⏰ 时间戳: 1728087655521

✅ 轨迹已完成！
================================================================================

✅ 前向轨迹已完成，等待3秒后发布后向轨迹...

================================================================================
📤 规划并发布后向轨迹（Traj3 倒车）
================================================================================
📋 后向轨迹规划 (倒车):
   起点: (4.000, 1.000), yaw=1.571 (90.0°)
   倒车距离: 1.000m
   ✅ 后向轨迹规划完成: 共 7 个路径点

所有路径点:
  点1: x=4.000, y=1.000, yaw=1.571 (90.0°)
  ...
  点7: x=4.000, y=0.000, yaw=1.571 (90.0°)

Beta-3参数: orientation=3.14, flag=1 (倒车运动)
================================================================================
📤 轨迹已发布到 /plans
📋 轨迹ID: complex_backward_1728087658890

✅ 所有轨迹发布完成
💡 保持运行以监听MQTT轨迹消息...
```

### 终端2（模拟执行器）再次输出

```
================================================================================
📥 收到轨迹指令                                   ← 【收到倒车轨迹】
================================================================================
📋 轨迹ID: complex_backward_1728087658890
📍 路径点数: 7
🔄 orientation: 3.14
🌿 flag: 1

起点: (4.000, 1.000), yaw=90.0°
终点: (4.000, 0.000), yaw=90.0°

执行估算:
  移动距离: 1.000 m
  旋转角度: 0.0°
  预计时间: 0.5 秒
================================================================================
📤 发布状态: running

⏳ 模拟执行轨迹... (0.5秒)
✅ 执行完成

📤 发布状态: completed                            ← 【发布第二次完成信号】
📍 当前位置: (4.000, 0.000), yaw=90.0°
```

---

## 关键点总结

### 1. **为什么需要mock_executor.py？**

**问题**：测试节点发布轨迹后，等待MQTT完成信号时**永久卡住**

**原因**：没有任何程序返回轨迹执行状态

**解决**：mock_executor.py模拟真实执行器，接收轨迹后返回MQTT状态

### 2. **mock_executor.py做了什么？**

1. **订阅 /plans**：接收测试节点发布的轨迹
2. **解析轨迹**：提取trajectory_id、orientation、flag等参数
3. **发布"running"**：通过MQTT告诉测试节点"开始执行"
4. **模拟延时**：根据距离和角度计算执行时间，延时模拟
5. **更新位置**：发布新的/Odom位置（模拟机器人移动）
6. **发布"completed"**：通过MQTT告诉测试节点"执行完成"

### 3. **MQTT消息流程**

```
测试节点                      mock_executor.py
   │                                │
   ├─── 发布前向轨迹到 /plans ─────→│
   │                                │
   │                           订阅到轨迹
   │                                │
   │                    发布MQTT "running"状态
   │                                │
   │←── MQTT订阅收到 "running" ─────┤
   │                                │
   │                           延时模拟执行
   │                                │
   │                   发布MQTT "completed"状态
   │                                │
   │←── MQTT订阅收到 "completed" ───┤
   │                                │
   ✅ 不再卡住，继续发布后向轨迹
```

### 4. **完整测试验证清单**

- [ ] 终端1：MQTT Bridge正常运行
- [ ] 终端2：**mock_executor.py正常运行**（关键！）
- [ ] 终端3：Odom数据持续发布
- [ ] 终端4：测试节点收到Odom
- [ ] 终端5：发布目标点
- [ ] 终端4：发布前向轨迹
- [ ] 终端2：收到前向轨迹，发布"running"状态
- [ ] 终端4：收到"running"状态
- [ ] 终端2：模拟执行，发布"completed"状态
- [ ] 终端4：**收到"completed"状态（不再卡住！）**
- [ ] 终端4：发布后向轨迹
- [ ] 终端2：收到后向轨迹，发布"running"和"completed"
- [ ] 终端4：收到第二次"completed"状态
- [ ] ✅ 测试完成！

---

## 常见问题

### Q1：测试节点还是卡在"等待MQTT轨迹完成信号"？

**检查**：终端2的mock_executor.py是否正在运行？

**解决**：必须启动mock_executor.py！

### Q2：mock_executor.py没有收到轨迹？

**检查**：
```bash
# 检查/plans话题是否有数据
ros2 topic echo /plans
```

**解决**：确保终端4的测试节点成功发布了轨迹

### Q3：MQTT状态消息没有收到？

**检查**：
- mock_executor.py的MQTT连接是否成功（看到"✅ MQTT已连接"）
- 测试节点的MQTT连接是否成功

---

## 快速启动脚本（推荐！）

可以创建一个脚本来简化测试：

```bash
#!/bin/bash
# 文件名：run_closed_loop_test.sh

echo "🚀 启动ComplexTrajectoryPlanner闭环测试"
echo ""
echo "请按顺序在不同终端运行以下命令："
echo ""
echo "终端1："
echo "  ./start_mqtt_bridge.sh"
echo ""
echo "终端2（关键！新增）："
echo "  python3 mock_executor.py"
echo ""
echo "终端3："
echo "  python3 publish_test_odom.py --x 3.0 --y 0.0 --yaw-deg -90"
echo ""
echo "终端4："
echo "  python3 test_complex_planner_workflow.py"
echo ""
echo "终端5（等终端4启动后）："
echo "  python3 publish_test_goal.py --x 4.0 --y 1.0 --yaw-deg 90"
echo ""
echo "✅ 现在测试可以完整运行，不会卡住！"
```

---

## 总结

✅ **mock_executor.py是闭环的关键**

- 接收 /plans 轨迹
- 返回 MQTT 状态消息（running → completed）
- 更新 /Odom 位置
- **让测试不再卡住，形成完整闭环！**

现在可以开始测试了！🚀
